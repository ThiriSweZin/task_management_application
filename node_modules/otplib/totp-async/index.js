/**
 * otplib-totp-async
 *
 * @author Gerald Yeo <contact@fusedthought.com>
 * @version: 12.0.0-1
 * @license: MIT
 **/
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var otplibTotp = require('../totp');
var otplibHotpAsync = require('../hotp-async');

async function totpDigestAsync(secret, options) {
  const counter = otplibTotp.totpCounter(options.epoch, options.step);
  return otplibHotpAsync.hotpDigestAsync(secret, counter, options);
}
async function totpTokenAsync(secret, options) {
  const digest = await totpDigestAsync(secret, options);
  return otplibTotp.totpToken(secret, { ...options,
    digest
  });
}
async function totpCheckAsync(token, secret, options) {
  const digest = await totpDigestAsync(secret, options);
  return otplibTotp.totpCheck(token, secret, { ...options,
    digest
  });
}
async function totpCheckByEpochAsync(epochs, token, secret, options) {
  let position = null;
  const digests = await Promise.all(epochs.map(epoch => totpDigestAsync(secret, { ...options,
    epoch
  })));
  digests.some((digest, idx) => {
    const result = otplibTotp.totpCheck(token, secret, { ...options,
      digest
    });
    if (result) {
      position = idx + 1;
      return true;
    }
    return false;
  });
  return position;
}
async function totpCheckWithWindowAsync(token, secret, options) {
  const checkZero = await totpCheckAsync(token, secret, options);
  if (checkZero) {
    return 0;
  }
  const epochs = otplibTotp.totpEpochAvailable(options.epoch, options.step, options.window);
  const backward = await totpCheckByEpochAsync(epochs.past, token, secret, options);
  if (backward !== null) {
    return backward * -1;
  }
  return totpCheckByEpochAsync(epochs.future, token, secret, options);
}
class TOTPAsync extends otplibHotpAsync.HOTPAsync {
  create(defaultOptions = {}) {
    return new TOTPAsync(defaultOptions);
  }
  allOptions() {
    return otplibTotp.totpOptions(this.options);
  }
  async generate(secret) {
    return totpTokenAsync(secret, this.allOptions());
  }
  async checkDelta(token, secret) {
    return totpCheckWithWindowAsync(token, secret, this.allOptions());
  }
  async check(token, secret) {
    const delta = await this.checkDelta(token, secret);
    return typeof delta === 'number';
  }
  async verify(opts) {
    return this.check(opts.token, opts.secret);
  }
  async timeRemaining() {
    const options = this.allOptions();
    return otplibTotp.totpTimeRemaining(options.epoch, options.step);
  }
  async timeUsed() {
    const options = this.allOptions();
    return otplibTotp.totpTimeUsed(options.epoch, options.step);
  }
  async keyuri(accountName, issuer, secret) {
    return otplibTotp.totpKeyuri(accountName, issuer, secret, this.allOptions());
  }
}

exports.TOTPAsync = TOTPAsync;
exports.totpCheckAsync = totpCheckAsync;
exports.totpCheckByEpochAsync = totpCheckByEpochAsync;
exports.totpCheckWithWindowAsync = totpCheckWithWindowAsync;
exports.totpDigestAsync = totpDigestAsync;
exports.totpTokenAsync = totpTokenAsync;
